{
  "version": 3,
  "sources": ["../../@solid-primitives/transition-group/dist/index.js", "../../@solid-primitives/refs/dist/index.js", "../../solid-transition-group/dist/index.js"],
  "sourcesContent": ["import { batch, createSignal, untrack, $TRACK, createComputed, createMemo, useTransition, } from \"solid-js\";\nimport { isServer } from \"solid-js/web\";\nconst noop = () => {\n    /* noop */\n};\nconst noopTransition = (el, done) => done();\n/**\n * Create an element transition interface for switching between single elements.\n * It can be used to implement own transition effect, or a custom `<Transition>`-like component.\n *\n * It will observe {@link source} and return a signal with array of elements to be rendered (current one and exiting ones).\n *\n * @param source a signal with the current element. Any nullish value will mean there is no element.\n * Any object can used as the source, but most likely you will want to use a `HTMLElement` or `SVGElement`.\n * @param options transition options {@link SwitchTransitionOptions}\n * @returns a signal with an array of the current element and exiting previous elements.\n *\n * @see https://github.com/solidjs-community/solid-primitives/tree/main/packages/transition-group#createSwitchTransition\n *\n * @example\n * const [el, setEl] = createSignal<HTMLDivElement>();\n *\n * const rendered = createSwitchTransition(el, {\n *   onEnter(el, done) {\n *     // the enter callback is called before the element is inserted into the DOM\n *     // so run the animation in the next animation frame / microtask\n *     queueMicrotask(() => { ... })\n *   },\n *   onExit(el, done) {\n *     // the exitting element is kept in the DOM until the done() callback is called\n *   },\n * })\n *\n * // change the source to trigger the transition\n * setEl(refToHtmlElement);\n */\nexport function createSwitchTransition(source, options) {\n    const initSource = untrack(source);\n    const initReturned = initSource ? [initSource] : [];\n    if (isServer) {\n        return () => initReturned;\n    }\n    const { onEnter = noopTransition, onExit = noopTransition } = options;\n    const [returned, setReturned] = createSignal(options.appear ? [] : initReturned);\n    const [isTransitionPending] = useTransition();\n    let next;\n    let isExiting = false;\n    function exitTransition(el, after) {\n        if (!el)\n            return after && after();\n        isExiting = true;\n        onExit(el, () => {\n            batch(() => {\n                isExiting = false;\n                setReturned(p => p.filter(e => e !== el));\n                after && after();\n            });\n        });\n    }\n    function enterTransition(after) {\n        const el = next;\n        if (!el)\n            return after && after();\n        next = undefined;\n        setReturned(p => [el, ...p]);\n        onEnter(el, after ?? noop);\n    }\n    const triggerTransitions = options.mode === \"out-in\"\n        ? // exit -> enter\n            // exit -> enter\n            prev => isExiting || exitTransition(prev, enterTransition)\n        : options.mode === \"in-out\"\n            ? // enter -> exit\n                // enter -> exit\n                prev => enterTransition(() => exitTransition(prev))\n            : // exit & enter\n                // exit & enter\n                prev => {\n                    exitTransition(prev);\n                    enterTransition();\n                };\n    createComputed((prev) => {\n        const el = source();\n        if (untrack(isTransitionPending)) {\n            // wait for pending transition to end before animating\n            isTransitionPending();\n            return prev;\n        }\n        if (el !== prev) {\n            next = el;\n            batch(() => untrack(() => triggerTransitions(prev)));\n        }\n        return el;\n    }, options.appear ? undefined : initSource);\n    return returned;\n}\n/**\n * Create an element list transition interface for changes to the list of elements.\n * It can be used to implement own transition effect, or a custom `<TransitionGroup>`-like component.\n *\n * It will observe {@link source} and return a signal with array of elements to be rendered (current ones and exiting ones).\n *\n * @param source a signal with the current list of elements.\n * Any object can used as the element, but most likely you will want to use a `HTMLElement` or `SVGElement`.\n * @param options transition options {@link ListTransitionOptions}\n *\n * @see https://github.com/solidjs-community/solid-primitives/tree/main/packages/transition-group#createListTransition\n *\n * @example\n * const [els, setEls] = createSignal<HTMLElement[]>([]);\n *\n * const rendered = createListTransition(els, {\n *   onChange({ list, added, removed, unchanged, finishRemoved }) {\n *     // the callback is called before the added elements are inserted into the DOM\n *     // so run the animation in the next animation frame / microtask\n *     queueMicrotask(() => { ... })\n *\n *     // the removed elements are kept in the DOM until the finishRemoved() callback is called\n *     finishRemoved(removed);\n *   }\n * })\n *\n * // change the source to trigger the transition\n * setEls([...refsToHTMLElements]);\n */\nexport function createListTransition(source, options) {\n    const initSource = untrack(source);\n    if (isServer) {\n        const copy = initSource.slice();\n        return () => copy;\n    }\n    const { onChange } = options;\n    // if appear is enabled, the initial transition won't have any previous elements.\n    // otherwise the elements will match and transition skipped, or transitioned if the source is different from the initial value\n    let prevSet = new Set(options.appear ? undefined : initSource);\n    const exiting = new WeakSet();\n    const [toRemove, setToRemove] = createSignal([], { equals: false });\n    const [isTransitionPending] = useTransition();\n    const finishRemoved = options.exitMethod === \"remove\"\n        ? noop\n        : els => {\n            setToRemove(p => (p.push.apply(p, els), p));\n            for (const el of els)\n                exiting.delete(el);\n        };\n    const handleRemoved = options.exitMethod === \"remove\"\n        ? noop\n        : options.exitMethod === \"keep-index\"\n            ? (els, el, i) => els.splice(i, 0, el)\n            : (els, el) => els.push(el);\n    return createMemo(prev => {\n        const elsToRemove = toRemove();\n        const sourceList = source();\n        sourceList[$TRACK]; // top level store tracking\n        if (untrack(isTransitionPending)) {\n            // wait for pending transition to end before animating\n            isTransitionPending();\n            return prev;\n        }\n        if (elsToRemove.length) {\n            const next = prev.filter(e => !elsToRemove.includes(e));\n            elsToRemove.length = 0;\n            onChange({ list: next, added: [], removed: [], unchanged: next, finishRemoved });\n            return next;\n        }\n        return untrack(() => {\n            const nextSet = new Set(sourceList);\n            const next = sourceList.slice();\n            const added = [];\n            const removed = [];\n            const unchanged = [];\n            for (const el of sourceList) {\n                (prevSet.has(el) ? unchanged : added).push(el);\n            }\n            let nothingChanged = !added.length;\n            for (let i = 0; i < prev.length; i++) {\n                const el = prev[i];\n                if (!nextSet.has(el)) {\n                    if (!exiting.has(el)) {\n                        removed.push(el);\n                        exiting.add(el);\n                    }\n                    handleRemoved(next, el, i);\n                }\n                if (nothingChanged && el !== next[i])\n                    nothingChanged = false;\n            }\n            // skip if nothing changed\n            if (!removed.length && nothingChanged)\n                return prev;\n            onChange({ list: next, added, removed, unchanged, finishRemoved });\n            prevSet = nextSet;\n            return next;\n        });\n    }, options.appear ? [] : initSource.slice());\n}\n", "import { chain, arrayEquals } from \"@solid-primitives/utils\";\nimport { children, createComputed, createMemo, onCleanup, untrack, } from \"solid-js\";\nimport { isServer } from \"solid-js/web\";\n/**\n * Utility for chaining multiple `ref` assignments with `props.ref` forwarding.\n * @param refs list of ref setters. Can be a `props.ref` prop for ref forwarding or a setter to a local variable (`el => ref = el`).\n * @example\n * ```tsx\n * interface ButtonProps {\n *    ref?: Ref<HTMLButtonElement>\n * }\n * function Button (props: ButtonProps) {\n *    let ref: HTMLButtonElement | undefined\n *    onMount(() => {\n *        // use the local ref\n *    })\n *    return <button ref={mergeRefs(props.ref, el => ref = el)} />\n * }\n *\n * // in consumer's component:\n * let ref: HTMLButtonElement | undefined\n * <Button ref={ref} />\n * ```\n */\nexport function mergeRefs(...refs) {\n    return chain(refs);\n}\n/**\n * Default predicate used in `resolveElements()` and `resolveFirst()` to filter Elements.\n *\n * On the client it uses `instanceof Element` check, on the server it checks for the object with `t` property. (generated by compiling JSX)\n */\nexport const defaultElementPredicate = isServer\n    ? (item) => item != null && typeof item === \"object\" && \"t\" in item\n    : (item) => item instanceof Element;\n/**\n * Utility for resolving recursively nested JSX children to a single element or an array of elements using a predicate.\n *\n * It does **not** create a computation - should be wrapped in one to repeat the resolution on changes.\n *\n * @param value JSX children\n * @param predicate predicate to filter elements\n * @returns single element or an array of elements or `null` if no elements were found\n */\nexport function getResolvedElements(value, predicate) {\n    if (predicate(value))\n        return value;\n    if (typeof value === \"function\" && !value.length)\n        return getResolvedElements(value(), predicate);\n    if (Array.isArray(value)) {\n        const results = [];\n        for (const item of value) {\n            const result = getResolvedElements(item, predicate);\n            if (result)\n                Array.isArray(result) ? results.push.apply(results, result) : results.push(result);\n        }\n        return results.length ? results : null;\n    }\n    return null;\n}\nexport function resolveElements(fn, predicate = defaultElementPredicate, serverPredicate = defaultElementPredicate) {\n    const children = createMemo(fn);\n    const memo = createMemo(() => getResolvedElements(children(), isServer ? serverPredicate : predicate));\n    memo.toArray = () => {\n        const value = memo();\n        return Array.isArray(value) ? value : value ? [value] : [];\n    };\n    return memo;\n}\n/**\n * Utility for resolving recursively nested JSX children in search of the first element that matches a predicate.\n *\n * It does **not** create a computation - should be wrapped in one to repeat the resolution on changes.\n *\n * @param value JSX children\n * @param predicate predicate to filter elements\n * @returns single found element or `null` if no elements were found\n */\nexport function getFirstChild(value, predicate) {\n    if (predicate(value))\n        return value;\n    if (typeof value === \"function\" && !value.length)\n        return getFirstChild(value(), predicate);\n    if (Array.isArray(value)) {\n        for (const item of value) {\n            const result = getFirstChild(item, predicate);\n            if (result)\n                return result;\n        }\n    }\n    return null;\n}\nexport function resolveFirst(fn, predicate = defaultElementPredicate, serverPredicate = defaultElementPredicate) {\n    const children = createMemo(fn);\n    return createMemo(() => getFirstChild(children(), isServer ? serverPredicate : predicate));\n}\n/**\n * Get up-to-date references of the multiple children elements.\n * @param ref Getter of current array of elements\n * @see https://github.com/solidjs-community/solid-primitives/tree/main/packages/refs#Refs\n * @example\n * ```tsx\n * const [refs, setRefs] = createSignal<Element[]>([]);\n * <Refs ref={setRefs}>\n *   {props.children}\n * </Refs>\n * ```\n */\nexport function Refs(props) {\n    if (isServer) {\n        return props.children;\n    }\n    const cb = props.ref, resolved = children(() => props.children);\n    let prev = [];\n    createComputed(() => {\n        const els = resolved.toArray().filter(defaultElementPredicate);\n        if (!arrayEquals(prev, els))\n            untrack(() => cb(els));\n        prev = els;\n    }, []);\n    onCleanup(() => prev.length && cb([]));\n    return resolved;\n}\n/**\n * Get up-to-date reference to a single child element.\n * @param ref Getter of current element *(or `undefined` if not mounted)*\n * @see https://github.com/solidjs-community/solid-primitives/tree/main/packages/refs#Ref\n * @example\n * ```tsx\n * const [ref, setRef] = createSignal<Element | undefined>();\n * <Ref ref={setRef}>\n *   {props.children}\n * </Ref>\n * ```\n */\nexport function Ref(props) {\n    if (isServer) {\n        return props.children;\n    }\n    const cb = props.ref, resolved = children(() => props.children);\n    let prev;\n    createComputed(() => {\n        const el = resolved.toArray().find(defaultElementPredicate);\n        if (el !== prev)\n            untrack(() => cb(el));\n        prev = el;\n    });\n    onCleanup(() => prev && cb(undefined));\n    return resolved;\n}\n", "import { createMemo } from \"solid-js\";\nimport { createSwitchTransition, createListTransition } from \"@solid-primitives/transition-group\";\nimport { resolveFirst, resolveElements } from \"@solid-primitives/refs\";\nfunction createClassnames(props) {\n    return createMemo(() => {\n        const name = props.name || \"s\";\n        return {\n            enterActive: (props.enterActiveClass || name + \"-enter-active\").split(\" \"),\n            enter: (props.enterClass || name + \"-enter\").split(\" \"),\n            enterTo: (props.enterToClass || name + \"-enter-to\").split(\" \"),\n            exitActive: (props.exitActiveClass || name + \"-exit-active\").split(\" \"),\n            exit: (props.exitClass || name + \"-exit\").split(\" \"),\n            exitTo: (props.exitToClass || name + \"-exit-to\").split(\" \"),\n            move: (props.moveClass || name + \"-move\").split(\" \"),\n        };\n    });\n}\n// https://github.com/solidjs-community/solid-transition-group/issues/12\n// for the css transition be triggered properly on firefox\n// we need to wait for two frames before changeing classes\nfunction nextFrame(fn) {\n    requestAnimationFrame(() => requestAnimationFrame(fn));\n}\n/**\n * Run an enter transition on an element - common for both Transition and TransitionGroup\n */\nfunction enterTransition(classes, events, el, done) {\n    const { onBeforeEnter, onEnter, onAfterEnter } = events;\n    // before the elements are added to the DOM\n    onBeforeEnter?.(el);\n    el.classList.add(...classes.enter);\n    el.classList.add(...classes.enterActive);\n    // after the microtask the elements will be added to the DOM\n    // and onEnter will be called in the same frame\n    queueMicrotask(() => {\n        // Don't animate element if it's not in the DOM\n        // This can happen when elements are changed under Suspense\n        if (!el.parentNode)\n            return done?.();\n        onEnter?.(el, () => endTransition());\n    });\n    nextFrame(() => {\n        el.classList.remove(...classes.enter);\n        el.classList.add(...classes.enterTo);\n        if (!onEnter || onEnter.length < 2) {\n            el.addEventListener(\"transitionend\", endTransition);\n            el.addEventListener(\"animationend\", endTransition);\n        }\n    });\n    function endTransition(e) {\n        if (!e || e.target === el) {\n            done?.(); // starts exit transition in \"in-out\" mode\n            el.removeEventListener(\"transitionend\", endTransition);\n            el.removeEventListener(\"animationend\", endTransition);\n            el.classList.remove(...classes.enterActive);\n            el.classList.remove(...classes.enterTo);\n            onAfterEnter?.(el);\n        }\n    }\n}\n/**\n * @private\n *\n * Run an exit transition on an element - common for both Transition and TransitionGroup\n */\nexport function exitTransition(classes, events, el, done) {\n    const { onBeforeExit, onExit, onAfterExit } = events;\n    // Don't animate element if it's not in the DOM\n    // This can happen when elements are changed under Suspense\n    if (!el.parentNode)\n        return done?.();\n    onBeforeExit?.(el);\n    el.classList.add(...classes.exit);\n    el.classList.add(...classes.exitActive);\n    onExit?.(el, () => endTransition());\n    nextFrame(() => {\n        el.classList.remove(...classes.exit);\n        el.classList.add(...classes.exitTo);\n        if (!onExit || onExit.length < 2) {\n            el.addEventListener(\"transitionend\", endTransition);\n            el.addEventListener(\"animationend\", endTransition);\n        }\n    });\n    function endTransition(e) {\n        if (!e || e.target === el) {\n            // calling done() will remove element from the DOM,\n            // but also trigger onChange callback in <TransitionGroup>.\n            // Which is why the classes need to removed afterwards,\n            // so that removing them won't change el styles when for the move transition\n            done?.();\n            el.removeEventListener(\"transitionend\", endTransition);\n            el.removeEventListener(\"animationend\", endTransition);\n            el.classList.remove(...classes.exitActive);\n            el.classList.remove(...classes.exitTo);\n            onAfterExit?.(el);\n        }\n    }\n}\nconst TRANSITION_MODE_MAP = {\n    inout: \"in-out\",\n    outin: \"out-in\",\n};\n/**\n * The `<Transition>` component lets you apply enter and leave animations on element passed to `props.children`.\n *\n * It only supports transitioning a single element at a time.\n *\n * @param props {@link TransitionProps}\n */\nexport const Transition = props => {\n    const classnames = createClassnames(props);\n    return createSwitchTransition(resolveFirst(() => props.children), {\n        mode: TRANSITION_MODE_MAP[props.mode],\n        appear: props.appear,\n        onEnter(el, done) {\n            enterTransition(classnames(), props, el, done);\n        },\n        onExit(el, done) {\n            exitTransition(classnames(), props, el, done);\n        },\n    });\n};\n/**\n * The `<TransitionGroup>` component lets you apply enter and leave animations on elements passed to `props.children`.\n *\n * It supports transitioning multiple elements at a time and moving elements around.\n *\n * @param props {@link TransitionGroupProps}\n */\nexport const TransitionGroup = props => {\n    const classnames = createClassnames(props);\n    return createListTransition(resolveElements(() => props.children).toArray, {\n        appear: props.appear,\n        exitMethod: \"keep-index\",\n        onChange({ added, removed, finishRemoved, list }) {\n            const classes = classnames();\n            // ENTER\n            for (const el of added) {\n                enterTransition(classes, props, el);\n            }\n            // MOVE\n            const toMove = [];\n            // get rects of elements before the changes to the DOM\n            for (const el of list) {\n                if (el.isConnected && (el instanceof HTMLElement || el instanceof SVGElement)) {\n                    toMove.push({ el, rect: el.getBoundingClientRect() });\n                }\n            }\n            // wait for th new list to be rendered\n            queueMicrotask(() => {\n                const moved = [];\n                for (const { el, rect } of toMove) {\n                    if (el.isConnected) {\n                        const newRect = el.getBoundingClientRect(), dX = rect.left - newRect.left, dY = rect.top - newRect.top;\n                        if (dX || dY) {\n                            // set els to their old position before transition\n                            el.style.transform = `translate(${dX}px, ${dY}px)`;\n                            el.style.transitionDuration = \"0s\";\n                            moved.push(el);\n                        }\n                    }\n                }\n                document.body.offsetHeight; // force reflow\n                for (const el of moved) {\n                    el.classList.add(...classes.move);\n                    // clear transition - els will move to their new position\n                    el.style.transform = el.style.transitionDuration = \"\";\n                    function endTransition(e) {\n                        if (e.target === el || /transform$/.test(e.propertyName)) {\n                            el.removeEventListener(\"transitionend\", endTransition);\n                            el.classList.remove(...classes.move);\n                        }\n                    }\n                    el.addEventListener(\"transitionend\", endTransition);\n                }\n            });\n            // EXIT\n            for (const el of removed) {\n                exitTransition(classes, props, el, () => finishRemoved([el]));\n            }\n        },\n    });\n};\n"],
  "mappings": "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",
  "names": ["exitTransition", "enterTransition", "children"]
}
